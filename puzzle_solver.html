<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‹¼å›¾æš´åŠ›æ±‚è§£å™¨</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .status-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .status-item {
            margin: 10px 0;
            font-size: 16px;
        }

        .status-item strong {
            color: #495057;
            display: inline-block;
            width: 120px;
        }

        .current-point {
            color: #007bff;
            font-weight: bold;
        }

        .controls {
            text-align: center;
            margin: 30px 0;
        }

        .solve-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .solve-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .solve-btn:active {
            transform: translateY(0);
        }

        .solve-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .log-section {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #4a5568;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: #a0aec0;
            margin-right: 10px;
        }

        .log-success {
            color: #48bb78;
        }

        .log-error {
            color: #fc8181;
        }

        .log-info {
            color: #63b3ed;
        }

        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 20px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .reset-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
            transition: background 0.3s ease;
        }

        .reset-btn:hover {
            background: #c82333;
        }

        /* å¼€å…³æ ·å¼ */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* æ€§èƒ½æ§åˆ¶åŒºåŸŸæ ·å¼ */
        .status-section h3 {
            margin-bottom: 15px;
            color: #495057;
            font-size: 16px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ§© æ‹¼å›¾æš´åŠ›æ±‚è§£å™¨</h1>

        <div class="status-section">
            <div class="status-item">
                <strong>å½“å‰è¿›åº¦:</strong>
                <span id="progressText">0 / 0</span>
            </div>
            <div class="status-item">
                <strong>å½“å‰ç‚¹ä½:</strong>
                <span class="current-point" id="currentPoint">ç­‰å¾…å¼€å§‹</span>
            </div>
            <div class="status-item">
                <strong>æ€§èƒ½æ¨¡å¼:</strong>
                <span style="color: #28a745; font-weight: bold;">âš¡ æé€Ÿæ¨¡å¼</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
        </div>

        <div class="controls">
            <button class="solve-btn" id="solveBtn" onclick="toggleAutoSolve()">
                ğŸš€ å¼€å§‹è‡ªåŠ¨æ±‚è§£
            </button>
            <button class="reset-btn" onclick="resetProgress()">
                ğŸ”„ é‡ç½®è¿›åº¦
            </button>
        </div>

        
        <div class="log-section" id="logSection">
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let currentPointIndex = 0;
        let isSolving = false;
        let isAutoSolving = false;
        let autoSolveTimer = null;
        const ADB_PROXY_URL = 'http://localhost:8085';
        let allPoints = [];
        let filteredPoints = [];
        let currentRound = 0;

        
        // ä» image_coordinate_picker.py ç§»æ¤çš„ points æ•°æ®
        const points = [];
        for (let row = 0; row < 19; row++) {
            const y = 580 + row * 54;
            const sx = row % 2 === 0 ? 110 : 200;
            for (let col = 0; col < (6 - row % 2); col++) {
                points.push([sx + col * 185, y]);
            }
        }
        // åˆå§‹åŒ–æ‰€æœ‰ç‚¹
        allPoints = [...points];
        filteredPoints = [...points];

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function () {
            updateStatus();
            addLog('ğŸš€ ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼ŒADB ä»£ç†å·²å°±ç»ª', 'success');
            addLog('âš¡ å·²å¯ç”¨æé€Ÿæ¨¡å¼ï¼ŒåŸºäºå‘½ä»¤å®ŒæˆçŠ¶æ€æ‰§è¡Œ', 'success');
        });

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus() {
            const totalPoints = filteredPoints.length;
            document.getElementById('progressText').textContent = `${currentPointIndex + 1} / ${totalPoints}`;
            document.getElementById('progressFill').style.width = `${((currentPointIndex + 1) / totalPoints) * 100}%`;
            document.getElementById('progressFill').textContent = `${Math.round(((currentPointIndex + 1) / totalPoints) * 100)}%`;

            if (filteredPoints.length > 0) {
                const [x, y] = filteredPoints[currentPointIndex];
                document.getElementById('currentPoint').textContent = `(${x}, ${y})`;
            }
        }

        // æ·»åŠ æ—¥å¿—
        function addLog(message, type = 'info') {
            const logSection = document.getElementById('logSection');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;

            const now = new Date();
            const timeStr = now.toTimeString().split(' ')[0];

            logEntry.innerHTML = `
                <span class="log-time">${timeStr}</span>
                ${message}
            `;

            logSection.appendChild(logEntry);
            logSection.scrollTop = logSection.scrollHeight;
        }

        // æ‰§è¡Œæ‹–åŠ¨æ“ä½œ
        async function performSwipe(startX, startY, endX, endY, duration = 500) {
            try {
                const response = await fetch(`${ADB_PROXY_URL}/swipe`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        startX: startX,
                        startY: startY,
                        endX: endX,
                        endY: endY,
                        duration: duration
                    })
                });

                const result = await response.json();
                return result.status === 'ok';
            } catch (error) {
                addLog(`æ‹–åŠ¨æ“ä½œå¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        // æ‰§è¡Œç‚¹å‡»æ“ä½œ
        async function performTap(x, y) {
            try {
                const response = await fetch(`${ADB_PROXY_URL}/tap`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        taps: [{ x: x, y: y }]
                    })
                });

                const result = await response.json();
                return result.status === 'ok';
            } catch (error) {
                addLog(`ç‚¹å‡»æ“ä½œå¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        // è·å–æˆªå›¾
        async function takeScreenshot() {
            try {
                const response = await fetch(`${ADB_PROXY_URL}/screenshot`, {
                    method: 'GET'
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                if (result.status === 'ok' && result.data) {
                    return result.data; // è¿”å›base64ç¼–ç çš„å›¾ç‰‡æ•°æ®
                } else {
                    throw new Error('æˆªå›¾è·å–å¤±è´¥');
                }
            } catch (error) {
                addLog(`æˆªå›¾è·å–å¤±è´¥: ${error.message}`, 'error');
                return null;
            }
        }

        // è·å–æŒ‡å®šåæ ‡çš„é¢œè‰²
        async function getPixelColor(imageData, x, y) {
            // åˆ›å»ºcanvasæ¥è§£æå›¾ç‰‡
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // è§£æbase64å›¾ç‰‡
            const img = new Image();
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = `data:image/png;base64,${imageData}`;
            });

            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            // è·å–åƒç´ æ•°æ®
            const pixelData = ctx.getImageData(x, y, 1, 1).data;
            return {
                r: pixelData[0],
                g: pixelData[1],
                b: pixelData[2]
            };
        }

        // è¿‡æ»¤ç‚¹ï¼šåªä¿ç•™é¢œè‰²ä¸º (36, 138, 114) çš„ç‚¹
        async function filterPointsByColor() {
            addLog('ğŸ“¸ å¼€å§‹è·å–æˆªå›¾è¿›è¡Œé¢œè‰²è¿‡æ»¤', 'info');

            const screenshot = await takeScreenshot();
            if (!screenshot) {
                addLog('âš ï¸ æˆªå›¾å¤±è´¥ï¼Œä½¿ç”¨æ‰€æœ‰ç‚¹ä½œä¸ºå¤‡é€‰', 'error');
                filteredPoints = [...allPoints];
                return;
            }

            addLog('ğŸ” å¼€å§‹åˆ†æç‚¹ä½é¢œè‰²...', 'info');
            const targetColor = { r: 36, g: 138, b: 114 };
            filteredPoints = [];
            let matchedCount = 0;

            for (let i = 0; i < allPoints.length; i++) {
                const [x, y] = allPoints[i];
                try {
                    const color = await getPixelColor(screenshot, x, y);

                    // æ£€æŸ¥é¢œè‰²æ˜¯å¦åŒ¹é…ï¼ˆå…è®¸å°å¹…è¯¯å·®ï¼‰
                    const diff = Math.abs(color.r - targetColor.r) +
                                Math.abs(color.g - targetColor.g) +
                                Math.abs(color.b - targetColor.b);

                    if (diff <= 10) { // å…è®¸10çš„é¢œè‰²è¯¯å·®
                        filteredPoints.push([x, y]);
                        matchedCount++;
                    }

                    // æ¯å¤„ç†10ä¸ªç‚¹æ›´æ–°ä¸€æ¬¡è¿›åº¦
                    if ((i + 1) % 10 === 0) {
                        addLog(`å·²æ£€æŸ¥ ${i + 1}/${allPoints.length} ä¸ªç‚¹ï¼Œæ‰¾åˆ° ${matchedCount} ä¸ªåŒ¹é…ç‚¹`, 'info');
                    }
                } catch (error) {
                    addLog(`æ£€æŸ¥ç‚¹ (${x}, ${y}) æ—¶å‡ºé”™: ${error.message}`, 'error');
                }
            }

            addLog(`âœ… é¢œè‰²è¿‡æ»¤å®Œæˆï¼ä» ${allPoints.length} ä¸ªç‚¹ä¸­ç­›é€‰å‡º ${filteredPoints.length} ä¸ªæœ‰æ•ˆç‚¹`, 'success');
        }

        // åˆ‡æ¢è‡ªåŠ¨æ±‚è§£çŠ¶æ€
        function toggleAutoSolve() {
            if (isAutoSolving) {
                stopAutoSolve();
            } else {
                startAutoSolve();
            }
        }

        // å¼€å§‹è‡ªåŠ¨æ±‚è§£
        async function startAutoSolve() {
            isAutoSolving = true;
            const solveBtn = document.getElementById('solveBtn');
            solveBtn.textContent = 'â¹ï¸ åœæ­¢æ±‚è§£';
            solveBtn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';

            addLog(`ğŸš€ å¼€å§‹ç¬¬ ${currentRound + 1} è½®è‡ªåŠ¨æ±‚è§£`, 'info');

            // æ¯è½®å¼€å§‹æ—¶è¿›è¡Œé¢œè‰²è¿‡æ»¤
            await filterPointsByColor();

            if (filteredPoints.length === 0) {
                addLog('âš ï¸ æ²¡æœ‰æ‰¾åˆ°åŒ¹é…é¢œè‰²çš„ç‚¹ï¼Œåœæ­¢æ±‚è§£', 'error');
                stopAutoSolve();
                return;
            }

            // é‡ç½®å½“å‰ç‚¹ä½ç´¢å¼•
            currentPointIndex = 0;
            updateStatus();

            // å¼€å§‹è‡ªåŠ¨æ‰§è¡Œå¾ªç¯
            await autoSolveLoop();
        }

        // åœæ­¢è‡ªåŠ¨æ±‚è§£
        function stopAutoSolve() {
            isAutoSolving = false;
            const solveBtn = document.getElementById('solveBtn');
            solveBtn.textContent = 'ğŸš€ å¼€å§‹è‡ªåŠ¨æ±‚è§£';
            solveBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';

            addLog('â¹ï¸ è‡ªåŠ¨æ±‚è§£å·²åœæ­¢', 'info');
        }

        // è‡ªåŠ¨æ±‚è§£å¾ªç¯ - æé€Ÿç‰ˆæœ¬
        async function autoSolveLoop() {
            while (isAutoSolving) {
                await solveNextPoint();

                // å¦‚æœè¿˜åœ¨è‡ªåŠ¨æ±‚è§£æ¨¡å¼ï¼ŒæçŸ­å»¶è¿Ÿåç«‹å³å¤„ç†ä¸‹ä¸€ä¸ªç‚¹
                if (isAutoSolving) {
                    await minimalDelay(20); // ä»…20mså»¶è¿Ÿï¼Œè®©ç•Œé¢èƒ½å“åº”
                }
            }
        }

        // æœ€å°å»¶è¿Ÿå‡½æ•° - ä»…ç”¨äºé˜²æ­¢ç•Œé¢å¡é¡¿
        async function minimalDelay(ms = 10) {
            // ADBå‘½ä»¤å·²ç»æ˜¯åŒæ­¥çš„ï¼Œè¿™é‡Œåªéœ€è¦æçŸ­å»¶è¿Ÿé¿å…ç•Œé¢å¡é¡¿
            if (ms > 0) {
                await sleep(ms);
            }
        }

        // æ±‚è§£ä¸‹ä¸€ä¸ªç‚¹ - æé€Ÿç‰ˆæœ¬
        async function solveNextPoint() {
            if (isSolving) return;

            isSolving = true;

            if (filteredPoints.length === 0) {
                addLog('æ²¡æœ‰å¯å¤„ç†çš„ç‚¹', 'error');
                isSolving = false;
                return;
            }

            const [x, y] = filteredPoints[currentPointIndex];
            addLog(`å¤„ç†ç¬¬ ${currentPointIndex + 1} ä¸ªç‚¹: (${x}, ${y})`, 'info');

            // ç¬¬ä¸€æ­¥ï¼šä» (100, 1720) æ‹–åŠ¨åˆ° (x, y+300)
            // ADBä»£ç†ä¼šç­‰å¾…å‘½ä»¤å®Œæˆæ‰è¿”å›ï¼Œä¸éœ€è¦é¢å¤–ç­‰å¾…
            const swipeSuccess = await performSwipe(100, 1720, x, y + 300, 300);

            if (!swipeSuccess) {
                addLog('æ‹–åŠ¨æ“ä½œå¤±è´¥ï¼Œåœæ­¢æœ¬æ¬¡æ±‚è§£', 'error');
                isSolving = false;
                if (isAutoSolving) {
                    stopAutoSolve();
                }
                return;
            }

            // æçŸ­å»¶è¿Ÿï¼Œä»…é¿å…ç•Œé¢å¡é¡¿
            await minimalDelay(5);

            // ç¬¬äºŒæ­¥ï¼šç‚¹å‡» (1050, 400)
            const tapSuccess = await performTap(1050, 400);

            if (!tapSuccess) {
                addLog('ç‚¹å‡»æ“ä½œå¤±è´¥ï¼Œåœæ­¢æœ¬æ¬¡æ±‚è§£', 'error');
                isSolving = false;
                if (isAutoSolving) {
                    stopAutoSolve();
                }
                return;
            }

            addLog(`âœ“ ç¬¬ ${currentPointIndex + 1} ä¸ªç‚¹å®Œæˆ`, 'success');

            // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªç‚¹
            currentPointIndex = (currentPointIndex + 1) % filteredPoints.length;

            // å¦‚æœå®Œæˆä¸€è½®ï¼Œæ˜¾ç¤ºå®Œæˆä¿¡æ¯
            if (currentPointIndex === 0) {
                currentRound++;
                addLog(`ğŸ‰ ç¬¬ ${currentRound} è½®å®Œæˆï¼`, 'success');

                // å¦‚æœè¿˜åœ¨è‡ªåŠ¨æ±‚è§£æ¨¡å¼ï¼Œå¼€å§‹æ–°ä¸€è½®
                if (isAutoSolving) {
                    await minimalDelay(50); // è½®æ¬¡é—´ç¨é•¿ä¸€ç‚¹çš„å»¶è¿Ÿ
                    await filterPointsByColor();

                    if (filteredPoints.length === 0) {
                        addLog('âš ï¸ æ–°ä¸€è½®æ²¡æœ‰æ‰¾åˆ°åŒ¹é…é¢œè‰²çš„ç‚¹ï¼Œåœæ­¢æ±‚è§£', 'error');
                        stopAutoSolve();
                        isSolving = false;
                        return;
                    }

                    currentPointIndex = 0;
                }
            }

            updateStatus();
            isSolving = false;
        }

        // é‡ç½®è¿›åº¦
        function resetProgress() {
            // åœæ­¢è‡ªåŠ¨æ±‚è§£
            if (isAutoSolving) {
                stopAutoSolve();
            }

            currentPointIndex = 0;
            currentRound = 0;
            filteredPoints = [...allPoints];
            updateStatus();
            addLog('è¿›åº¦å·²é‡ç½®', 'info');
        }

        // è¾…åŠ©å‡½æ•°ï¼šå»¶è¿Ÿ
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function (event) {
            if (event.code === 'Space') {
                event.preventDefault();
                toggleAutoSolve();
            } else if (event.code === 'KeyR' && event.ctrlKey) {
                event.preventDefault();
                resetProgress();
            }
        });
    </script>
</body>

</html>